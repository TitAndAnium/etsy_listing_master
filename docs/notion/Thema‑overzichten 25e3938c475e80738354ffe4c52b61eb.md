# Thema‑overzichten

**Security:**

- *Positief:* Secrets management is goed (env files, geen keys in repo). Er is aandacht voor abuse-preventie via rate limiting in de vorm van credits en budget caps. Stripe-webhook validatie is correct geïmplementeerd (verificatie van signature) wat spoofing voorkomt. Firestore rules bestaan en beperken al veel (users alleen eigen data schrijven/lezen).
- *Negatief:* Authenticatie ontbreekt op kritieke endpoints – dit is het grootste gat (zie hierboven). Firestore rules zijn nog niet stringent genoeg voor productie (admin/auth scopes moeten duidelijker). Input wordt niet gefilterd op eventuele injection attempts richting OpenAI (kan mogelijk misbruikt worden om promptregels te negeren, zij het minder kritisch). Ook CORS staat open voor alle domeinen, wat bijvoorbeeld embedded gebruik door derden mogelijk maakt – overweeg hier beperking.
- *Verbetering:* Auth middleware toevoegen is prioriteit #1 (zie takenlijst). Daarna Firestore security testen en fixen. Overweeg verder een soort usage throttling per IP/user om DoS tegen te gaan – nu is er wel creditslimiet maar bij een nieuwe user kan iemand telkens opnieuw registreren. Misschien een Cloud Functions rate limit of gebruik van Firebase App Check om alleen verkeer van de eigen app toe te staan.

**Architectuur:**

- *Positief:* Duidelijke scheiding tussen frontend (Vue SPA) en backend (Firebase Functions). Gebruik van serverless functies maakt schaalbaarheid en deployment handig. Code is modulair: functies in afzonderlijke bestanden (`generateFromDumpCore.js`, `credits.js`, validators). Logging- en validatielogica is centraal gehouden, wat duplicatie voorkomt. Ook is er consistentie in error handling en structuur (HTTP 4xx voor client errors, 5xx voor intern).
- *Negatief/op risico:* De monorepo bevat zowel frontend als backend; build en deploy moeten goed afgestemd worden (nu niet duidelijk hoe frontend wordt gebouwd/hosted – potentieel via Firebase Hosting?). Kleine architectuurswitches (Next -> Vue) hebben wat sporen nagelaten in documentatie en mogelijk code (bv. een `/frontend/` map genoemd in logs, die nu niet meer bestaat). Dit vereist opletten bij opschonen.
- *Verbetering:* Beslis of de frontend in deze repo blijft of apart gaat. Zo ja, verwijder overbodige oude config (er staat bijv. iets van `onebox-hacker/frontend/node_modules/...` in zip – wellicht een vergeten directory). Documenteer de deployment pipeline van de frontend. Zorg dat in de code alle oude referenties (zoals `testuser123` forcing in http_generateFromDumpCore) eruit zijn als dat niet meer nodig is.

**Payments:**

- *Positief:* Integratie met Stripe is professioneel aangepakt: gebruik van Checkout Sessions (veilige verwerking) en Webhooks voor post-payment acties. De Stripe secret en webhook_secret worden niet hardcoded maar via config geladen. De webhook functie is beveiligd tegen ongeautoriseerde calls (verificatie met `Stripe.webhooks.constructEvent`) en voert een nette Firestore transaction uit om race conditions te vermijden. Het systeem gebruikt metadata (uid, credits) om bij te houden wat er gekocht is, wat een gangbaar patroon is.
- *Negatief:* Zoals aangegeven, de server valideert de relatie bedrag-credits niet; momenteel moet men vertrouwen op de front/client. Dit is oplosbaar door vaste prijzen of herberekenen. Ook is er nog geen mechanisme om *failed* payments of *partial* payments af te handelen – Stripe sessions kunnen bijv. verlopen zonder betaling; de huidige implementatie doet niks in zo’n geval (wat op zich oké is). Er is geen melding of verwerk van `checkout.session.expired` events, maar dat hoeft ook niet strikt.
- *Verbetering:* Implementeer een prijs/credits mapping server-side. Eventueel zou je kunnen loggen wanneer iemand een Payment doet (bijv. een `creditsPurchaseLogs` collectie) voor analyse, maar dat is optioneel. Denk erover na of refunds nodig zijn (waarschijnlijk niet hier, credits zijn digitaal goed). Controleer ook of `appBaseUrl` correct is gezet voor productie in de code – nu default op localhost:5173, wat straks aangepast moet worden. Tenslotte, test de hele flow in testmodus (Stripe test keys) end-to-end.

**Firebase:**

- *Positief:* Gebruik van Firebase is passend: Firestore voor persistente opslag (users, logs, etc.), Functions voor backend. Er is al voorzien in `firebase.json` en `.firebaserc` voor emulator en deploy config. De code gebruikt de Admin SDK (initializeApp) zodat men server-side privileges heeft. Firestore transactions worden correct gebruikt voor atomaire updates (bv. credits optellen). Men heeft ook Firestore.rules aangemaakt wat duidt op bewustzijn van beveiliging op dataniveau.
- *Negatief:* De Firestore rules zijn nog niet volledig tight (zie hierboven bij Security). Ook ontbreken er misschien nog index-definities als er complexe queries komen (hoewel in deze app waarschijnlijk weinig queries, alles key-based op uid). .runtimeconfig.json wordt lokaal gelezen voor stripe config fallback – zorg dat dit niet per ongeluk mee deployed wordt (hoewel .gitignore het uitsluit).
- *Verbetering:* Na aanscherping van de rules: voer een *Firestore Security Review* uit (via Firebase emulator “Rules Testing” of zelfs een derde laten proberen te hacken). Documenteer duidelijk welke collections gebruikt worden en of er backup-/retentiebeleid is (bijv. logt men gevoelige data die men na X dagen moet opschonen?). Mogelijk moet `firestore.indexes.json` nog gecheckt worden als er queries op bijv. timestamp of uid+date in logs zijn; nu lijkt alles directe doc access, dus geen index issues verwacht.

**Data/Privacy:**

- *Positief:* Er worden nauwelijks direct identificerende persoonsgegevens verwerkt – vooral gebruikerscontent (etsy listings, gekozen parameters) en usage data. Alle geheimen en user tokens blijven server-side. Credit card gegevens worden geheel door Stripe afgehandeld (GDPR-compliance via Stripe). Firestore gebruikersdocumenten lijken enkel een uid en credit-aantallen te bevatten, wat privacy-risico minimaal houdt.
- *Negatief:* In logs kunnen stukjes door gebruiker aangeleverde tekst of AI output opgeslagen zijn. Dit kan zakelijke gevoelige info bevatten (bijv. unieke productomschrijvingen). Hoewel niet persoonlijk, valt dit onder user-provided content die beschermd moet worden. Er is nog geen expliciete privacy policy of opt-in bekend voor gebruikers die dit systeem gaan gebruiken – dat is meer een organisatorisch punt. Ook het langdurig bewaren van AI-gegenereerde content zou vragen kunnen oproepen (sommige gebruikers willen misschien niet dat hun data lang gelogged wordt).
- *Verbetering:* Stel een bewaartermijn voor de Firestore logs/collecties. Bijvoorbeeld: verwijder generation logs ouder dan 30 dagen, tenzij nodig voor analytics. Dit kan geautomatiseerd met een Cloud Function (scheduled function) of via Firestore TTL-index als preview feature. Communiceer naar gebruikers (in de UI of voorwaarden) hoe hun data gebruikt wordt – bijv. “We bewaren gegenereerde teksten en invoer voor 30 dagen ter verbetering van de service.” Zorg ook dat bij account deletion (als dat relevant wordt) alle bijbehorende logs/credits verwijderd worden.

**CI/CD:**

- *Positief:* Continuous Integration is duidelijk aanwezig. Er draait een workflow `ci.yml` die secret scanning en tests omvat. Het project heeft ook scripts voor emulators en test in package.json (wat integratie in CI vergemakkelijkt). De huidige pipeline status is goed – alle tests slagen en geen secrets detected. Het team heeft CI al gebruikt om quality-gates te bewaken (bijv. secret-scan groen gemeld, E2E test pipeline). Dit duidt op een volwassen proces.
- *Negatief:* CD (Continuous Deployment) lijkt nog niet ingesteld of is niet zichtbaar. Deploy zal nu manueel via Firebase CLI verlopen. Ook is coverage nog niet 100% (maar dat is geen harde eis, wel mooi te hebben).
- *Verbetering:* Breid de GitHub Actions pipeline eventueel uit met een deploy-step naar Firebase (voor functions en hosting) die triggered op een tag of merge naar main. Zorg dat er enige gating is – bv. alleen deploy als tests pass én wellicht een manual approval als het productie betreft. Overweeg ook om in CI regelmatig vulnerabilities scan (via `npm audit` of Snyk) en een linter/formatter check mee te nemen, om code quality consistent te houden.

**A11y (Toegankelijkheid):**

- *Positief:* Enkele toegankelijkheidsvoorzieningen zijn impliciet aanwezig: labels bij form velden, duidelijke secties voor status indicaties (kleurcodes en iconen), en een voornemen om alt-text voor images te genereren. De interface lijkt grotendeels tekst-gebaseerd output te geven, wat voor screenreaders goed is.
- *Negatief:* Er is nog geen expliciete vermeldingen van toetsenbordnavigatie of aria-attributes. Componenten als toggles en dropdowns moeten ARIA-roles krijgen en focus management (geen info in code daarover gezien). Kleurindicaties moeten voor contrast voldoen (nog te testen of geel/rood voldoende contrast hebben op de gekozen achtergrond). Het *Pro-mode* concept (strengere validatie) is een toggle – moet ook duidelijk zijn voor screenreader wat dat doet.
- *Verbetering:* Voer een basic accessibility audit uit (bijv. via Lighthouse of axe). Controleer header-structuur, label-associaties, contrast ratio’s. Voeg waar nodig aria-labels toe, zoals aan regeneratie-knoppen (“Genereer titel opnieuw” als tekst voor screenreader). Overweeg om foutmeldingen (bv. “Daily credits exhausted”) ook te tonen in de UI op een manier die toegankelijk is (rol=alert). Dit alles zijn kleine aanpassingen, maar waardevol voor brede toegankelijkheid.